# ~/.bashrc_linux
# =========================
#  bash shell configuration
# =========================


# only use this file on Linux
if [[ "${OSTYPE}" != "linux"* ]]; then
    return
fi


# make less more friendly for non-text input files
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"


# expand aliases when running sudo
alias sudo="sudo "


# run sudo with existing environment variables and tab-completion enabled
# (needed for gui apps)
alias gsudo="sudo --preserve-env"
complete -F _root_command gsudo


# expand aliases when running watch
alias watch="watch "


# exit shell
alias x="history -n; history -w; exit"


# look all busy and fancy to non-technical people
alias busy="cat /dev/urandom | hexdump -C | \grep --color=always 'ca fe'"


# disk space
alias df="\df --human-readable --local --sync"
alias ds="diskspace"


# watch disk space
alias diskwatch="watch --interval 2 --exec bash -c diskspace"
alias dw="diskwatch"


# kill process group by name (case-insensitive)
alias killall="\killall --ignore-case --process-group --wait"


# remove Rust/Cargo crate source checkouts and git repo checkouts
alias clean-rust="rustup update && cargo-cache --autoclean"


# don't leave .wget-hsts file in home directory
alias wget="wget --hsts-file=/dev/null"


# python virtual env
alias activate="source ./venv/bin/activate"
alias deact="deactivate"
alias venv="[ ! -d venv/ ] && python3 -m venv --upgrade-deps venv \
    && activate || activate"


# show tcp/udp sockets actively listening
alias listening="sudo netstat --listening --inet --inet6 --program \
    --symbolic | grep -v 'connections'"


# show tcp/udp sockets with established connections
alias sockets="sudo netstat --all --inet --inet6 --program \
    --symbolic | grep -v 'connections' | grep -v 'sunrpc.*init' | grep -v 'LISTEN'"


# open github website in default browser
alias gith="xdg-open https://github.com"
alias gist="xdg-open https://gist.github.com/${GITHUB_USERNAME}"


# open url or file in default browser
alias web="sensible-browser"


# ncurses disk usage
alias ncdu="ncdu --disable-delete --group-directories-first \
    --one-file-system --show-itemcount"


# list directories and files in tree format
alias tree="tree -ash -CF --du"


# ip addresses
alias internalip="echo 'internal ip address:' && echo '---------------------' && \
    hostname --all-ip-addresses | awk '{print \$1}'"
alias externalip="echo 'external ip addresses:' && echo '----------------------' && \
    curl ipv4.icanhazip.com && curl ipv6.icanhazip.com"
alias ips="internalip && echo && externalip"


# --------------------------------- FUNCTIONS ---------------------------------


# show disk space of root filesystem and include remote storage if its mounted
diskspace () {
    local dirs=(
        "${HOME}/bitz"
        "${HOME}/bytez"
    )
    echo -e "Location\tFilesystem      Size  Used Avail Use% Mounted on"
    echo "----------------------------------------------------------------"
    echo -en "local\t\t"
    df --human-readable --local --sync / | \grep -v "Filesystem"
    for d in "${dirs[@]}"; do
        remotes="true"
        if [ -d "${d}" ]; then
            echo -en "$(basename ${d})\t\t"
            df --human-readable --local --sync "${d}" | \grep -v "Filesystem"
        fi
    done
}
export -f diskspace


# mount 2-bay NAS
bitz () {
    # requires `gvfs-backends`
    local host="bitz"
    local ip="10.0.0.5"
    local username="cgoldberg"
    local share="public"
    gio mount "smb://${username}@${ip}/${share}" 2>/dev/null
    ln -s "/run/user/1000/gvfs/smb-share:server=${ip},share=${share},user=${username}" \
        "${HOME}/${host}" 2>/dev/null
    cd "${HOME}/${host}" 2>/dev/null
}


# mount 1-bay NAS
bytez () {
    # requires `gvfs-backends`
    local host="bytez"
    local ip="10.0.0.6"
    local username="cgoldberg"
    local share="public"
    gio mount "smb://${username}@${ip}/${share}" 2>/dev/null
    ln -s "/run/user/1000/gvfs/smb-share:server=${ip},share=${share},user=${username}" \
        "${HOME}/${host}" 2>/dev/null
    cd "${HOME}/${host}" 2>/dev/null
}


# install chrome from google repo
install-chrome () {
    local package="google-chrome-stable"
    if dpkg-query -Wf'${db:Status-abbrev}' "${package}" 2>/dev/null | \grep -q '^i'; then
        err "${package} is already installed"
        return 1
    else
        echo "deb [arch=amd64] https://dl.google.com/linux/chrome/deb/ stable main" \
            | sudo tee /etc/apt/sources.list.d/google-chrome.list
        sudo apt update
        sudo apt install "${package}" -y
    fi
}


# remove metadata from an image
# usage: clean-img-metadata <image_file_or_glob> ...
clean-img-metadata () {
    if [ -z "$1" ]; then
        err "please specify an image file or glob pattern"
        return 1
    fi
    if [ ! -x "$(type -pP exiv2)" ]; then
        err "exiv2 not installed"
        return 1
    fi
    exiv2 -k -v delete "$@"
}


# run jekyll server for blog and open local url in browser
blog () {
    local blog_dir="${HOME}/code/cgoldberg.github.io"
    local jekyll_server="127.0.0.1:4000"
    if [ ! -d "${blog_dir}" ]; then
        err "${blog_dir} not found"
        return 1
    elif [ ! -x "$(type -pP bundle)" ]; then
        err "bundler not found"
        return 1
    fi
    killblog
    echo "running server at: ${jekyll_server}"
    cd "${blog_dir}"
    bundle exec jekyll s >/dev/null & disown # silence stdout
    sleep 3.5
    echo "opening browser at: http://${jekyll_server}"
    xdg-open "http://${jekyll_server}"
}


# kill jekyll server running blog
killblog () {
    local blog_dir="${HOME}/code/cgoldberg.github.io"
    local jekyll_proc="jekyll s"
    local jekyll_server="127.0.0.1:4000"
    if [ ! -d "${blog_dir}" ]; then
        err "${blog_dir} not found. no server running"
        return 1
    fi
    if [[ $(psgrep "${jekyll_proc}") ]]; then
        echo "killing server at: ${jekyll_server}"
        pkill -9 -f "${jekyll_proc}" && pidwait -f "${jekyll_proc}"
        psgrep "${jekyll_proc}" | grep -v grep
    fi
}


# package maintenance
apt-up () {
    # reload package index files from sources
    sudo apt update --no-allow-insecure-repositories && echo &&
    # check for broken dependencies
    sudo apt-get check && echo &&
    # fix broken dependencies
    sudo apt install --fix-broken && echo &&
    # fix missing dependencies
    sudo apt install --fix-missing && echo &&
    # upgrade installed packages
    sudo apt full-upgrade && echo &&
    # purge packages that are no longer needed
    sudo apt autoremove --purge && echo &&
    # remove cached packages
    sudo apt clean &&
    # purge orphaned configs from removed packages
    purge-apt-configs &&
    # reload package index files from sources
    sudo apt update --no-allow-insecure-repositories && echo &&
    # print number of installed packages
    ok "$(dpkg -l | grep -c '^ii') packages installed"
}


# purge configuration data from packages marked as removed
purge-apt-configs () {
    if dpkg -l | grep --quiet '^rc'; then
        echo "$(dpkg -l | grep -c '^rc') packages have orphaned configs"
        echo "purging package configs from removed packages..."
        dpkg -l | grep '^rc' | awk '{print $2}' | xargs sudo dpkg --purge
    fi
}


# update pyenv
# uninstall each python installation
# install latest of each major python version
# update pip in each python installation
update-pyenv () {
    if [ ! -d "${HOME}/.pyenv" ]; then
        err "pyenv is not installed"
        return 1
    fi
    if [ -n "${VIRTUAL_ENV}" ]; then
        echo "deactivating venv"
        deactivate
    fi
    echo
    pyenv global system
    echo "updating pyenv ..."
    pyenv update
    pyenv rehash
    echo
    for py_version in "${PY_VERSIONS[@]}"; do
        local minor_versions=( $(pyenv versions --bare | \grep "${py_version}") )
        for minor_version in "${minor_versions[@]}"; do
            echo "uninstalling Python ${minor_version} ..."
            pyenv uninstall --force "${minor_version}"
            echo
        done
        echo "installing latest version of Python ${py_version} ..."
        pyenv install --force --verbose "${py_version}"
        pyenv global "${py_version}"
        echo "installed $(python3 --version)"
        echo
        echo "updating pip ..."
        PIP_REQUIRE_VIRTUALENV=false python3 -m pip install --upgrade \
            --upgrade-strategy=eager pip
        echo
    done
    pyenv rehash
    eval "pyenv global ${PY_VERSIONS[*]}"
    echo "global python versions installed:"
    pyenv global
}


# -----------------------------------------------------------------------------


# pyenv
if [ -d "${HOME}/.pyenv" ]; then
    export PYENV_ROOT="${HOME}/.pyenv"
    [[ -d "${PYENV_ROOT}/bin" ]] && export PATH="${PYENV_ROOT}/bin:${PATH}"
    eval "$(pyenv init - bash)"
    PY_VERSIONS=("3.14" "3.13" "3.12" "3.11" "3.10" "pypy3.11")
    eval "pyenv global ${PY_VERSIONS[*]}"
fi
