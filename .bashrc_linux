# ~/.bashrc_linux
# =========================
#  bash shell configuration
# =========================


# this file only works on Linux
if [[ "${OSTYPE}" != "linux"* ]]; then
    return
fi


export GITHUB_USERNAME="cgoldberg"


# set a color prompt with: chroot (if in a chroot), user@host:dir, git branch (if in a git repo)
export GIT_PS1_HIDE_IF_PWD_IGNORED=1
export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWSTASHSTATE=1
export GIT_PS1_SHOWUPSTREAM="auto"
custom_prompt='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\[\033[0;32m\]$(__git_ps1 " (%s) ")\[\033[0m\]\$ '
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
    custom_prompt="\[\033[00;31m\]${debian_chroot:+($debian_chroot)} ${custom_prompt}"
fi
PS1="${custom_prompt}"


# make less more friendly for non-text input files
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"


# run sudo with existing environment variables and tab-completion enabled (needed for gui apps)
alias gsudo="sudo --preserve-env"
complete -F _root_command gsudo


# expand aliases when running sudo
alias sudo="sudo "


# expand aliases when running watch
alias watch="watch "


# kill process group by name (case-insensitive)
alias killall="\killall --ignore-case --process-group --wait"


# don't leave .wget-hsts file in home directory
alias wget="wget --hsts-file=/dev/null"


# show TCP and UDP sockets that are actively listening
alias listening="sudo netstat --listening --program --symbolic --tcp --udp"


# open github website in default browser
alias gith="xdg-open https://github.com"
alias gist="xdg-open https://gist.github.com/${GITHUB_USERNAME}"


# open url or file in default browser
alias web="sensible-browser"


# disk space
alias df="\df --human-readable --sync"
alias ds="\df --human-readable --sync | \grep --extended-regexp '/dev/kvm|Filesystem'"


# disk usage (directory sizes)
alias du="\du --human-readable --time --max-depth=1"


# ncurses disk usage (requires ncdu package)
alias ncdu="ncdu --disable-delete --group-directories-first --one-file-system --show-itemcount"


# memory usage
alias mem="free --human --si | \grep --extended-regex 'Mem|total'"


# list directories and files in tree format
alias tree="tree -ash -CF --du"


# show how a command would be interpreted (includes: aliases, builtins, functions, scripts/executables on path)
alias which="type"


# python virtual env
alias activate="source ./venv/bin/activate"
alias act="activate"
alias deact="deactivate"


# ip addresses
alias internalip="echo 'internal ip addresss:' && echo '---------------------' && \
    hostname --all-ip-addresses | awk '{print \$1}'"
alias externalip="echo 'external ip addresses:' && echo '----------------------' && \
    curl ipv4.icanhazip.com && curl ipv6.icanhazip.com"
alias ips="echo 'ip addresses:' && echo '-------------' && \
    hostname --all-ip-addresses | awk '{print \$1}' && \
    curl ipv4.icanhazip.com && curl ipv6.icanhazip.com"


# --------------------------------- FUNCTIONS ---------------------------------


# clean python dev/temp files from current directory and subdirectories
clean-py () {
    echo "cleaning python dev/temp files ..."
    local dirs=(
        "build/"
        "dist/"
    )
    local recurse_dirs=(
        "*.egg-info/"
        ".mypy_cache/"
        ".pytest_cache/"
        ".ruff_cache/"
        ".tox/"
        ".venv/"
        "__pycache__/"
        "venv/"
    )
    if [ ! -z "${VIRTUAL_ENV}" ]; then
        echo "deactivating venv"
        deactivate
    fi
    for d in ${dirs[@]}; do
        if [ -d "${d}" ]; then
            echo "deleting ${d}"
            rm -rf "${d}"
        fi
    done
    for d in ${recurse_dirs[@]}; do
        echo "recursively deleting ${d}"
        rm -rf ./**/${d}/
    done
}


# remove metadata from an image
clean-metadata () {
    if [ -z "$1" ]; then
        err "usage: clean-metadata <image_file>"
        return 1
    fi
    if [ -f /usr/bin/exiv2 ]; then
        exiv2 -k -v delete "$1"
    else
        err "exiv2 not installed"
    fi
}


# run jekyll server for blog and open local url in browser
blog () {
    local blog_dir="${HOME}/code/cgoldberg.github.io"
    local jekyll_server="127.0.0.1:4000"
    if [ ! -d "${blog_dir}" ]; then
        err "${blog_dir} not found"
        return 1
    elif [ ! -x "$(command -v bundle)" ]; then
        err "bundler not found"
        return 1
    fi
    killblog
    echo "running server at: ${jekyll_server}"
    cd ${blog_dir}
    bundle exec jekyll s >/dev/null & disown # silence stdout
    sleep 3.5
    echo "opening browser at: http://${jekyll_server}"
    xdg-open "http://${jekyll_server}"
}


# kill jekyll server running blog
killblog () {
    local blog_dir="${HOME}/code/cgoldberg.github.io"
    local jekyll_proc="jekyll s"
    local jekyll_server="127.0.0.1:4000"
    if [ ! -d "${blog_dir}" ]; then
        err "${blog_dir} not found. no server running"
        return 1
    fi
    if [[ $(psgrep "${jekyll_proc}") ]]; then
        echo "killing server at: ${jekyll_server}"
        pkill -9 -f "${jekyll_proc}" && pidwait -f "${jekyll_proc}"
        psgrep "${jekyll_proc}"
    fi
}


# package maintenance
apt-up () {
    # reload package index files from sources
    sudo apt --no-allow-insecure-repositories update && echo &&
    # upgrade installed packages
    sudo apt full-upgrade && echo &&
    # check for broken dependencies
    sudo apt-get check && echo &&
    # fix broken dependencies
    sudo apt --fix-broken install && echo &&
    # fix missing dependencies
    sudo apt --fix-missing install && echo &&
    # purge packages that are no longer needed
    sudo apt --purge autoremove && echo &&
    # remove cached packages
    sudo apt clean &&
    # purge orphaned configs from removed packages
    purge-apt-configs &&
    # reload package index files from sources
    sudo apt --no-allow-insecure-repositories update && echo
}


# purge configuration data from packages marked as removed
purge-apt-configs () {
    if dpkg -l | grep --quiet '^rc'; then
        echo "$(dpkg -l | grep '^rc' | wc -l) packages have orphaned configs"
        echo "purging package configs from removed packages..."
        dpkg -l | grep '^rc' | awk '{print $2}' | xargs sudo dpkg --purge
    fi
}


# backup public github repos and google drive and store in a tarball in ~/backup
backup-all () {
    local backup_dir="${HOME}/backup"
    local backup_archive="./backups.tar.gz"
    if [ ! ${backup_dir} ]; then
        err "backup directory not found"
        return 1
    fi
    if [ ! -x "$(command -v google_drive_export)" ]; then
        err "google_drive_export not found"
        return 1
    fi
    if [ ! -x "$(command -v githubtakeout)" ]; then
        err "githubtakeout not found"
        return 1
    fi
    echo
    echo "Changing directory to: ${backup_dir}"
    cd "${backup_dir}"
    rm -f "${backup_archive}"
    rm -rf ./exported_files
    rm -rf ./backups
    rm -rf ./google_drive_files
    rm -rf ./github_archives
    google_drive_export
    echo
    githubtakeout "${GITHUB_USERNAME}" --format=tar
    mv ./exported_files ./google_drive_files
    mv ./backups ./github_archives
    tar cvzf "${backup_archive}" *
    echo
    echo "Changing directory back to: ${OLDPWD}"
    cd "${OLDPWD}"
}


# update pyenv, plugins, and pip in every python installation
update-pyenv () {
    if [ ! -d "${HOME}/.pyenv" ]; then
        err "pyenv is not installed"
        return 1
    fi
    if [ ! -z "${VIRTUAL_ENV}" ]; then
        echo "deactivating venv"
        deactivate
    fi
    echo "updating pyenv and plugins ..."
    pyenv update
    pyenv rehash
    echo
    for py_version in ${py_versions[@]}; do
        pyenv global ${py_version}
        echo "version installed: $(python --version)"
        echo "version available: Python $(pyenv latest ${py_version})"
        echo "updating pip ..."
        python3 -m pip install --upgrade pip
        echo
    done
    eval "pyenv global ${py_versions[*]}"
}


# -----------------------------------------------------------------------------


# ruby gems
if [ -d "${HOME}/.gems" ]; then
    export GEM_HOME="${HOME}/.gems"
    export PATH="${PATH}:${HOME}/.gems/bin"
fi


# pipx
if [ -x "$(command -v pipx)" ]; then
    eval "$(register-python-argcomplete pipx)"
fi


# pyenv
if [ -d "${HOME}/.pyenv" ]; then
    export PYENV_ROOT="${HOME}/.pyenv"
    [[ -d "${PYENV_ROOT}/bin" ]] && export PATH="${PYENV_ROOT}/bin:${PATH}"
    eval "$(pyenv init - bash)"
    py_versions=("3.13" "3.12" "3.11" "3.10" "3.9" "pypy3.11")
    eval "pyenv global ${py_versions[*]}"
fi


# atuin - shell history/search (https://atuin.sh)
#   - ctrl-r to activate
#   - run autuin-update to update the binary
if [ -d "${HOME}/.atuin" ]; then
    source "${HOME}/.atuin/bin/env"
    [[ -f "${HOME}/.bash-preexec.sh" ]] && source "${HOME}/.bash-preexec.sh"
    eval "$(atuin init bash --disable-up-arrow)"
fi
