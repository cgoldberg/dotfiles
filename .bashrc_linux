# ~/.bashrc_linux
# =========================
#  bash shell configuration
# =========================


# only use this file on Linux
if [[ "${OSTYPE}" != "linux"* ]]; then
    return
fi


# make less more friendly for non-text input files
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"


# expand aliases when running sudo
alias sudo="sudo "


# expand aliases when running watch
alias watch="watch "


# exit shell
alias x="exit"


# look all busy and fancy to non-technical people
alias busy="cat /dev/urandom | hexdump -C | \grep --color=always 'ca fe'"


# disk space
alias df="df --human-readable --portability --print-type --sync"


# watch disk space
alias diskwatch="watch --no-wrap --interval 5 --exec bash -c diskspace"
alias dw="diskwatch"


# monitor cpu and device/partition i/o stats
alias iostat="iostat -p --human --pretty 2"


# monitor bandwidth
alias bmon="bmon --use-bit --use-si --policy='wlan*,eth*'"


# monitor resources (cpu/mem/disk/net/procs)
alias btop="btop --preset 0 --update 2000"


# kill process group by name (case-insensitive)
alias killall="killall --ignore-case --process-group --wait"


# don't leave .wget-hsts file in home directory
alias wget="wget --hsts-file=/dev/null"


# python virtual env
alias activate="source ./venv/bin/activate"
alias deact="deactivate"
alias venv="[ ! -d venv/ ] && python3 -m venv --upgrade-deps venv \
    && activate || activate"


# show tcp/udp listening sockets
# and summary of network connections
alias listening="ss --summary --listening --processes --resolve --tcp --udp"


# show tcp/udp non-listening sockets
# and summary of network connections
alias sockets="ss --summary --processes --resolve --tcp --udp"


# open url or file in default browser
alias web="sensible-browser"


# ncurses disk usage
alias ncdu="ncdu --disable-delete --group-directories-first \
    --one-file-system --show-itemcount"


# --------------------------------- FUNCTIONS ---------------------------------


diskspace () {
    echo "Filesystem        Type      Size  Used Avail Use% Mounted on"
    echo "------------------------------------------------------------"
    df | \grep -E -- 'ext4|cifs|media'
}
# make it available in non-interactive shells so watch can see it
export -f diskspace
alias ds="diskspace"


# mount 2-bay NAS
bitz () {
    local mnt="/mnt/bitz"
    if ! findmnt "${mnt}" >/dev/null; then
        sudo mount -t cifs //10.0.0.5/public "${mnt}" \
            -o credentials=/root/.smbcredentials,relatime,nofail,_netdev,gid=1000,uid=1000,file_mode=0664,dir_mode=0775,iocharset=utf8
    fi
    cd "${mnt}"
}


# mount 1-bay NAS
bytez () {
    local mnt="/mnt/bytez"
    if ! findmnt "${mnt}" >/dev/null; then
        sudo mount -t cifs //10.0.0.5/public "${mnt}" \
            -o credentials=/root/.smbcredentials,relatime,nofail,_netdev,gid=1000,uid=1000,file_mode=0664,dir_mode=0775,iocharset=utf8
    fi
    cd "${mnt}"
}


# install chrome from google repo
install-chrome () {
    local package="google-chrome-stable"
    if dpkg-query -Wf'${db:Status-abbrev}' "${package}" 2>/dev/null | \grep -q '^i'; then
        err "${package} is already installed"
        return 1
    else
        echo "deb [arch=amd64] https://dl.google.com/linux/chrome/deb/ stable main" \
            | sudo tee /etc/apt/sources.list.d/google-chrome.list
        sudo apt update --no-allow-insecure-repositories
        sudo apt install "${package}" -y
    fi
}


# show internal/external ip addresses
ips () {
    echo "internal ip addresses:"
    echo "----------------------"
    hostname --all-ip-addresses | tr -d '\n' | sed 's/ /\n/g'
    echo
    echo "external ip addresses:"
    echo "----------------------"
    curl ipv4.icanhazip.com
    curl ipv6.icanhazip.com
}


# run jekyll server for blog and open local url in browser
blog () {
    local blog_dir="${HOME}/code/cgoldberg.github.io"
    local jekyll_server="127.0.0.1:4000"
    if [ ! -d "${blog_dir}" ]; then
        err "${blog_dir} not found"
        return 1
    elif [ ! -x "$(type -pP bundle)" ]; then
        err "bundler not found"
        return 1
    fi
    killblog
    echo "running server at: ${jekyll_server}"
    cd "${blog_dir}"
    bundle exec jekyll s >/dev/null & disown # silence stdout
    sleep 3.5
    echo "opening browser at: http://${jekyll_server}"
    web "http://${jekyll_server}"
}


# kill jekyll server running blog
killblog () {
    local blog_dir="${HOME}/code/cgoldberg.github.io"
    local jekyll_proc="jekyll s"
    local jekyll_server="127.0.0.1:4000"
    if [ ! -d "${blog_dir}" ]; then
        err "${blog_dir} not found. no server running"
        return 1
    fi
    if [[ $(psgrep "${jekyll_proc}") ]]; then
        echo "killing server at: ${jekyll_server}"
        pkill -9 -f "${jekyll_proc}" && pidwait -f "${jekyll_proc}"
        psgrep "${jekyll_proc}"
    fi
}


# whack the thumbnail cache
clean-thumbnails () {
    rm -rf "${HOME}/.cache/thumbnails/"
    ok "cleaned thumbnail cache"
}


# whack the package resource lists
clean-apt-index () {
    sudo rm -rf /var/lib/apt/lists/*
    ok "cleaned package resource lists"
}


# remove CUE sheet from FLAC files in current directory
clean-flac-cuesheets () {
    if [ ! -x "$(type -pP metaflac)" ]; then
        err "metaflac not found"
        return 1
    fi
    local num_files="$(\ls -1q *.flac | wc -l)"
    metaflac --remove --block-type='CUESHEET' *.flac
    ok "cleaned CUE sheets from ${num_files} FLAC files"
}


# package maintenance
apt-up () {
    sudo apt update --no-allow-insecure-repositories \
        || (err "apt error" && return 1)
    ok "updated list of available packages\n"
    sudo apt install --fix-broken \
        || (err "apt error" && return 1)
    ok "fixed broken dependencies\n"
    sudo apt install --fix-missing \
        || (err "apt error" && return 1)
    ok "fixed missing dependencies\n"
    sudo apt full-upgrade \
        || (err "apt error" && return 1)
    ok "upgraded installed packages\n"
    sudo apt autoremove --purge \
        || (err "apt error" && return 1)
    ok "removed unused packages\n"
    sudo apt clean \
        || (err "apt error" && return 1)
    ok "removed cached packages\n"
    if dpkg -l | grep --quiet '^rc'; then
        echo "$(dpkg -l | grep -c '^rc') packages have orphaned configs"
        dpkg -l | grep '^rc' | awk '{print $2}' \
            | xargs --no-run-if-empty sudo dpkg --purge
    fi
    ok "purged orphaned package configs\n"
    sudo apt update --no-allow-insecure-repositories \
        || (err "apt error" && return 1)
    ok "updated list of available packages\n"
    # print number of installed packages
    ok "$(dpkg -l | grep -c '^ii') packages installed"
}


# show locally installed .deb packages
apt-show-local-pkgs () {
    apt list --installed 2>/dev/null | \grep installed,local | cut -d'/' -f1
}


# update locally installed .deb packages
update-apt-local-pkgs () {
    if [ ! -x "$(type -pP gh)" ]; then
        err "can't find github cli"
        return 1
    fi
    if [ "$(arch)" == "aarch64" ]; then
        local architecture="arm64"
    else
        local architecture="amd64"
    fi
    local packages=$(apt-show-local-pkgs)
    local original_dir=${PWD}
    rm -f /tmp/*.deb
    for pkg in ${packages[@]}; do
        local pkg_repo_dir="${HOME}/code/${pkg}"
        if [ ! -d "${pkg_repo_dir}" ]; then
            echo
            err "can't find git repo for package: ${pkg}"
            echo
            echo "locally cloned repos are required at:"
            for pkg in ${packages[@]}; do
                echo " - ${HOME}/code/${pkg}"
            done
            return 1
        fi
    done
    for pkg in ${packages[@]}; do
        local pkg_repo_dir="${HOME}/code/${pkg}"
        cd "${pkg_repo_dir}"
        echo
        echo "downloading latest release of package: '${pkg}' ..."
        gh release download --clobber --pattern="*${architecture}.deb" --dir="/tmp"
        for deb in /tmp/*"${architecture}.deb"; do
            if [[ ${deb} != *"musl"* ]]; then
                echo "installing ..."
                sudo apt install -y "${deb}"
                echo
            fi
            rm "${deb}"
            cd "${original_dir}"
        done
    done
    cd "${original_dir}"
    ok "done upgrading locally installed packages"
}


# update python interpreters with pyenv
# - update pyenv
# - uninstall every python installation
# - install latest version of each python interpreter
# - update pip in each python installation
# - re-install pipx with most recent python interpreter and update all pipx applications
update-pyenv () {
    if [ ! -d "${HOME}/.pyenv" ]; then
        err "pyenv is not installed"
        return 1
    fi
    if [ -n "${VIRTUAL_ENV}" ]; then
        echo "deactivating venv"
        deactivate
    fi
    echo
    pyenv global system
    echo "updating pyenv ..."
    pyenv update
    pyenv rehash
    echo
    local minor_versions=( $(pyenv versions --bare | \grep "${py_version}") )
    for minor_version in "${minor_versions[@]}"; do
        echo "uninstalling Python ${minor_version} ..."
        pyenv uninstall --force "${minor_version}"
        echo
    done
    for py_version in "${PY_VERSIONS[@]}"; do
        echo "installing latest version of Python ${py_version} ..."
        pyenv install --force --verbose "${py_version}"
        pyenv global "${py_version}"
        echo "installed $(python3 --version)"
        echo
        echo "updating pip ..."
        PIP_REQUIRE_VIRTUALENV=false python3 -m pip install --upgrade \
            --upgrade-strategy=eager pip
        echo
    done
    pyenv rehash
    pyenv global "${PY_VERSIONS[0]}"
    pip-uninstall-all
    gpip-install pipx
    pipx-upgrade-all
    echo
    pyenv global ${PY_VERSIONS[*]}
    echo "global python versions installed:"
    pyenv global
    echo
    ok "done updating pythons"
}


# -----------------------------------------------------------------------------


# pyenv
if [ -d "${HOME}/.pyenv" ]; then
    export PYENV_ROOT="${HOME}/.pyenv"
    [[ -d "${PYENV_ROOT}/bin" ]] && export PATH="${PYENV_ROOT}/bin:${PATH}"
    eval "$(pyenv init - bash)"
    PY_VERSIONS=("3.14" "3.13" "3.12" "3.11" "3.10" "pypy3.11")
    eval "pyenv global ${PY_VERSIONS[*]}"
fi
